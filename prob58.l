(defun is-prime(n)
  (do ((i 2 (1+ i)))
      ((> (* i i) n) (return-from is-prime t))
      (cond ((zerop (mod n i)) (return-from is-prime nil)))))
(defun main()
  (do ((eg 3 (+ 2 eg)) (cur-number 3 (+ 2 cur-number)) (add-num 2 (+ 2 add-num)) (prime-cnt 0))
      (nil)
      (cond ((and (/= eg 3) (< (* 10 (/ prime-cnt ( 1+ (* 4 (1- (/ eg 2)))))) 1))
	     (print (- eg 2)) (return-from main nil))
	    (t
	     (dotimes (i 4)
	       (cond ((is-prime cur-number) (incf prime-cnt)))
	       (setf cur-number (+ cur-number add-num)))))))
(main)
    

;;(load "util.l")
;; (defun is-prime(x)
;;   (cond ((equal x 1) (return-from is-prime nil)))
;;   (do ((i 2 (1+ i)))
;;       ((> (* i i) x) (return-from is-prime t))
;;       (cond ((zerop (mod x i)) (return-from is-prime nil)))))
;; (defun main()
;;   (let ((num 1) (cnt 0))
;;     (do ((eg 3 (+ eg 2)))
;; 	((and (null (equal eg 3))
;; 	      (> 1/10 (/ cnt (1+ (* 4 (1- (floor eg 2)))))))
;; 	 (return-from main eg))
;; 	;(print eg)
;; 	(dotimes (x 4)
;; 	  (setf num (+ num 2))
;; 	  (cond ((is-prime num) (incf cnt))))
;; 	;; (cond ((null (equal eg 3))
;; 	;;        (print (/ (* 1.0 cnt) (* 4 (1- (floor eg 2)))))))
;; 	)))
;; (print (main))
